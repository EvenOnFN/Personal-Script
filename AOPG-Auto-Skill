-- Load Linoria Library
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

-- Anti-AFK Setup
local VirtualUser = game:GetService("VirtualUser")
player.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new())
end)

-- Create Window
local Window = Library:CreateWindow({
    Title = 'Auto Skills',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- Create Tab
local Tabs = {
    Main = Window:AddTab('Main'),
}

-- Variables
local autoQEnabled = false
local autoEEnabled = false
local autoTPQEnabled = false
local autoM1Enabled = false
local autoSmartGachaEnabled = false
local autoSmartGemCapEnabled = false
local autoDragonSummonEnabled = false
local qConnection, eConnection, tpqConnection, m1Connection, smartGachaConnection, smartGemCapConnection, dragonSummonConnection = nil, nil, nil, nil, nil, nil, nil
local lastQAttackTime, lastEAttackTime, lastTPQAttackTime = 0, 0, 0
local attackDelay = 0.1
local tpHeight = 5

-- Main Tab Groups
local EscanorSkillGroup = Tabs.Main:AddLeftGroupbox('Escanor')
local TPFarmGroup = Tabs.Main:AddRightGroupbox('TP Farm')
local M1Group = Tabs.Main:AddRightGroupbox('Auto M1')
local AutoBuyGroup = Tabs.Main:AddLeftGroupbox('Smart Christmas Gacha')
local GemCapGroup = Tabs.Main:AddLeftGroupbox('Smart Gem Cap Increase')
local DragonSummonGroup = Tabs.Main:AddRightGroupbox('Auto Dragon Summon')

-- Function to check if model has NpcMarker
local function hasNpcMarker(model)
    for _, child in pairs(model:GetDescendants()) do
        if child:IsA("BillboardGui") and child.Name == "NpcMarker" then
            return true
        end
    end
    return false
end

-- Function to check if something is a raid mob
local function isRaidMob(model)
    if not model:IsA("Model") then return false end
    if not model:FindFirstChild("Humanoid") then return false end
    if not model:FindFirstChild("HumanoidRootPart") then return false end
    if Players:GetPlayerFromCharacter(model) then return false end
    local humanoid = model:FindFirstChild("Humanoid")
    if humanoid.Health <= 0 then return false end
    if not hasNpcMarker(model) then return false end
    return true
end

-- Function to find nearest raid mob
local function findNearestRaidMob()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    local playerPos = player.Character.HumanoidRootPart.Position
    local nearestMob, nearestDistance = nil, math.huge
    if workspace:FindFirstChild("Entities") then
        for _, model in pairs(workspace.Entities:GetChildren()) do
            if isRaidMob(model) then
                local mobHRP = model:FindFirstChild("HumanoidRootPart")
                if mobHRP then
                    local distance = (playerPos - mobHRP.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestMob = model
                    end
                end
            end
        end
    end
    return nearestMob
end

-- Function to get a suitable target part for abilities
local function getTargetPart()
    if workspace:FindFirstChild("Raid Map") then
        for _, child in pairs(workspace["Raid Map"]:GetChildren()) do
            if child:IsA("MeshPart") and child.Name:find("newcake") then return child end
        end
        for _, child in pairs(workspace["Raid Map"]:GetChildren()) do
            if child:IsA("MeshPart") then return child end
        end
        if workspace["Raid Map"]:FindFirstChild("Model") then return workspace["Raid Map"].Model end
    else
        local dawnIsland = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Islands") and workspace.Map.Islands:FindFirstChild("Dawn Island")
        if dawnIsland and dawnIsland:FindFirstChild("Model") then
            local model = dawnIsland.Model:FindFirstChild("Dawn Island")
            if model and model:FindFirstChild("Model") then
                local meshPart = model.Model:FindFirstChild("Meshes/daniland.2")
                if meshPart then return meshPart end
            end
        end
    end
    return workspace
end

-- Function to get skill args
local function getSkillArgs(skill)
    return {
        "Sword Style",
        skill,
        player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart.CFrame or CFrame.new(0, 0, 0),
        getTargetPart(),
        5
    }
end

-- Function to teleport to position
local function teleportToPosition(targetPosition)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
    end
end

-- Function to perform M1 attack
local function performM1()
    pcall(function()
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("requestAbility"):FireServer(unpack(getSkillArgs("MouseButton1")))
    end)
end

-- Function to get player's currency (you'll need to find where this is stored)
local function getCurrency()
    -- This is a placeholder - you'll need to find where the currency is stored
    -- Common locations: player.leaderstats, player.Data, PlayerGui, etc.
    local currency = 0
    pcall(function()
        -- Try common locations
        if player:FindFirstChild("leaderstats") and player.leaderstats:FindFirstChild("Currency") then
            currency = player.leaderstats.Currency.Value
        elseif player:FindFirstChild("Data") and player.Data:FindFirstChild("Currency") then
            currency = player.Data.Currency.Value
        end
    end)
    return currency
end

-- Smart buy gacha based on currency
local function smartBuyGacha()
    pcall(function()
        local currency = getCurrency()
        local version = 1 -- Default to cheapest
        
        if currency >= 1000 then
            version = 3 -- Buy expensive version
        elseif currency >= 500 then
            version = 2 -- Buy medium version
        elseif currency >= 100 then
            version = 1 -- Buy cheap version
        else
            return -- Not enough currency
        end
        
        player:WaitForChild("PlayerGui"):WaitForChild("NewPresentShop"):WaitForChild("buy"):FireServer(version)
    end)
end

-- Smart increase gem cap based on currency
local function smartIncreaseGemCap()
    pcall(function()
        local currency = getCurrency()
        local amount = 1 -- Default to cheapest
        
        if currency >= 10 then
            amount = 10 -- Buy expensive version
        elseif currency >= 5 then
            amount = 5 -- Buy medium version
        elseif currency >= 1 then
            amount = 1 -- Buy cheap version
        else
            return -- Not enough currency
        end
        
        player:WaitForChild("PlayerGui"):WaitForChild("NewPoneglyphMerchant"):WaitForChild("Event"):FireServer(amount)
    end)
end

-- Function to summon dragon
local function summonDragon()
    pcall(function()
        ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("clonegui"):FireServer("Dragon Summoner")
        wait(0.3)
        local gui = player:WaitForChild("PlayerGui")
        local dragonSummoner = gui:FindFirstChild("Dragon Summoner")
        if dragonSummoner then
            local eventRemote = dragonSummoner:FindFirstChild("Event")
            if eventRemote then
                eventRemote:FireServer()
                wait(0.1)
                dragonSummoner:Destroy()
            end
        end
    end)
end

-- Toggle for Auto Q Skill
EscanorSkillGroup:AddToggle('AutoQ', {
    Text = 'Escanor Q',
    Default = false,
    Tooltip = 'Automatically uses Q skill when raid mob detected',
    Callback = function(value)
        autoQEnabled = value
        if value then
            Library:Notify('‚úÖ Escanor Q enabled!')
            qConnection = RunService.Heartbeat:Connect(function()
                if not autoQEnabled then return end
                local mob = findNearestRaidMob()
                if mob and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
                    local currentTime = tick()
                    if currentTime - lastQAttackTime >= attackDelay then
                        pcall(function()
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("requestAbility"):FireServer(unpack(getSkillArgs("Q")))
                        end)
                        lastQAttackTime = currentTime
                    end
                end
            end)
        else
            Library:Notify('‚ùå Escanor Q disabled.')
            if qConnection then qConnection:Disconnect() qConnection = nil end
        end
    end
})

EscanorSkillGroup:AddDivider()

-- Toggle for Auto E Skill
EscanorSkillGroup:AddToggle('AutoE', {
    Text = 'Escanor E',
    Default = false,
    Tooltip = 'Automatically uses E skill when raid mob detected',
    Callback = function(value)
        autoEEnabled = value
        if value then
            Library:Notify('‚úÖ Escanor E enabled!')
            eConnection = RunService.Heartbeat:Connect(function()
                if not autoEEnabled then return end
                local mob = findNearestRaidMob()
                if mob and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 then
                    local currentTime = tick()
                    if currentTime - lastEAttackTime >= attackDelay then
                        pcall(function()
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("requestAbility"):FireServer(unpack(getSkillArgs("E")))
                        end)
                        lastEAttackTime = currentTime
                    end
                end
            end)
        else
            Library:Notify('‚ùå Escanor E disabled.')
            if eConnection then eConnection:Disconnect() eConnection = nil end
        end
    end
})

EscanorSkillGroup:AddDivider()
EscanorSkillGroup:AddLabel('Attacks mobs with NpcMarker')
EscanorSkillGroup:AddLabel('No teleportation')
EscanorSkillGroup:AddDivider()
EscanorSkillGroup:AddLabel('üü¢ Anti-AFK: Active')

-- Toggle for Auto TP + Q Farm
TPFarmGroup:AddToggle('AutoTPQ', {
    Text = 'Auto TP + Q Farm',
    Default = false,
    Tooltip = 'Teleports to raid mob and uses Q skill',
    Callback = function(value)
        autoTPQEnabled = value
        if value then
            Library:Notify('‚úÖ Auto TP + Q Farm enabled!')
            tpqConnection = RunService.Heartbeat:Connect(function()
                if not autoTPQEnabled then return end
                local mob = findNearestRaidMob()
                if mob and mob:FindFirstChild("Humanoid") and mob:FindFirstChild("HumanoidRootPart") and mob.Humanoid.Health > 0 then
                    teleportToPosition(mob.HumanoidRootPart.Position + Vector3.new(0, tpHeight, 0))
                    local currentTime = tick()
                    if currentTime - lastTPQAttackTime >= attackDelay then
                        pcall(function()
                            ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("requestAbility"):FireServer(unpack(getSkillArgs("Q")))
                        end)
                        lastTPQAttackTime = currentTime
                    end
                end
            end)
        else
            Library:Notify('‚ùå Auto TP + Q Farm disabled.')
            if tpqConnection then tpqConnection:Disconnect() tpqConnection = nil end
        end
    end
})

TPFarmGroup:AddDivider()
TPFarmGroup:AddLabel('Teleports to mob')
TPFarmGroup:AddLabel('Uses Q skill')

-- Toggle for Auto M1
M1Group:AddToggle('AutoM1', {
    Text = 'Auto M1 (Sword Style)',
    Default = false,
    Tooltip = 'Automatically spams Sword Style M1 at all times',
    Callback = function(value)
        autoM1Enabled = value
        if value then
            Library:Notify('‚úÖ Auto M1 enabled!')
            m1Connection = RunService.Heartbeat:Connect(function()
                if not autoM1Enabled then return end
                performM1()
            end)
        else
            Library:Notify('‚ùå Auto M1 disabled.')
            if m1Connection then m1Connection:Disconnect() m1Connection = nil end
        end
    end
})

M1Group:AddDivider()
M1Group:AddLabel('Uses Sword Style M1')
M1Group:AddLabel('Spams constantly')

-- Toggle for Smart Buy Gacha
AutoBuyGroup:AddToggle('AutoSmartGacha', {
    Text = 'Smart Buy Christmas Gacha',
    Default = false,
    Tooltip = 'Buys the best gacha based on your currency',
    Callback = function(value)
        autoSmartGachaEnabled = value
        if value then
            Library:Notify('‚úÖ Smart Christmas Gacha enabled!')
            smartGachaConnection = RunService.Heartbeat:Connect(function()
                if not autoSmartGachaEnabled then return end
                smartBuyGacha()
            end)
        else
            Library:Notify('‚ùå Smart Christmas Gacha disabled.')
            if smartGachaConnection then smartGachaConnection:Disconnect() smartGachaConnection = nil end
        end
    end
})

AutoBuyGroup:AddDivider()
AutoBuyGroup:AddLabel('Auto buys best version:')
AutoBuyGroup:AddLabel('1000+ ‚Üí Version 3')
AutoBuyGroup:AddLabel('500+ ‚Üí Version 2')
AutoBuyGroup:AddLabel('100+ ‚Üí Version 1')

-- Toggle for Smart Increase Gem Cap
GemCapGroup:AddToggle('AutoSmartGemCap', {
    Text = 'Smart Increase Gem Cap',
    Default = false,
    Tooltip = 'Increases gem cap with best option for your currency',
    Callback = function(value)
        autoSmartGemCapEnabled = value
        if value then
            Library:Notify('‚úÖ Smart Gem Cap enabled!')
            smartGemCapConnection = RunService.Heartbeat:Connect(function()
                if not autoSmartGemCapEnabled then return end
                smartIncreaseGemCap()
            end)
        else
            Library:Notify('‚ùå Smart Gem Cap disabled.')
            if smartGemCapConnection then smartGemCapConnection:Disconnect() smartGemCapConnection = nil end
        end
    end
})

GemCapGroup:AddDivider()
GemCapGroup:AddLabel('Auto buys best option:')
GemCapGroup:AddLabel('10+ ‚Üí Buy 10')
GemCapGroup:AddLabel('5+ ‚Üí Buy 5')
GemCapGroup:AddLabel('1+ ‚Üí Buy 1')

-- Toggle for Auto Dragon Summon
DragonSummonGroup:AddToggle('AutoDragonSummon', {
    Text = 'Auto Dragon Summon',
    Default = false,
    Tooltip = 'Automatically summons dragon with no delay',
    Callback = function(value)
        autoDragonSummonEnabled = value
        if value then
            Library:Notify('‚úÖ Auto Dragon Summon enabled!')
            dragonSummonConnection = RunService.Heartbeat:Connect(function()
                if not autoDragonSummonEnabled then return end
                summonDragon()
            end)
        else
            Library:Notify('‚ùå Auto Dragon Summon disabled.')
            if dragonSummonConnection then dragonSummonConnection:Disconnect() dragonSummonConnection = nil end
        end
    end
})

DragonSummonGroup:AddDivider()
DragonSummonGroup:AddLabel('Opens, confirms & closes GUI')
DragonSummonGroup:AddLabel('Requires Fire Dragon Key')

-- UI Settings
Library:SetWatermarkVisibility(false)

-- Unload cleanup
local function Unload()
    if qConnection then qConnection:Disconnect() end
    if eConnection then eConnection:Disconnect() end
    if tpqConnection then tpqConnection:Disconnect() end
    if m1Connection then m1Connection:Disconnect() end
    if smartGachaConnection then smartGachaConnection:Disconnect() end
    if smartGemCapConnection then smartGemCapConnection:Disconnect() end
    if dragonSummonConnection then dragonSummonConnection:Disconnect() end
    Library:Unload()
end

Library:OnUnload(Unload)

print("‚úÖ Auto Q & E Skill script loaded!")
